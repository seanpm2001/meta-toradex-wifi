From 48e652c1c82ef188ad5d46f70e23502e65f49131 Mon Sep 17 00:00:00 2001
From: Rafael Beims <rafael.beims@toradex.com>
Date: Sat, 18 Mar 2023 08:49:18 -0300
Subject: [PATCH] Patch for kernel 5.15

---
 bt/bt_drv.h     | 29 ++++++++++++++++++++++++-----
 bt/bt_init.c    | 14 ++++++++++++++
 bt/bt_main.c    |  2 +-
 bt/bt_proc.c    | 27 +++++++++++++++++++++++++++
 bt/bt_sdiommc.c |  9 ++++++++-
 bt/mbt_char.c   | 22 ++++++++++++++++++++++
 6 files changed, 96 insertions(+), 7 deletions(-)

diff --git a/bt/bt_drv.h b/bt/bt_drv.h
index 64323ca..09efa93 100755
--- a/bt/bt_drv.h
+++ b/bt/bt_drv.h
@@ -556,8 +556,13 @@ struct proc_private_data {
 	struct item_data *pdata;
 	/** Private structure */
 	struct _bt_private *pbt;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+	/** File operations */
+	const struct proc_ops *fops;
+#else
 	/** File operations */
 	const struct file_operations *fops;
+#endif
 };
 
 /** Device proc structure */
@@ -572,6 +577,14 @@ struct device_proc {
 	struct proc_private_data *pfiles;
 };
 
+/** timeval */
+typedef struct {
+        /** Time (seconds) */
+        u32 tv_sec;
+        /** Time (micro seconds) */
+        u32 tv_usec;
+} bt_timeval;  
+
 /** Private structure for the MV device */
 typedef struct _bt_private {
 	/** Bluetooth device */
@@ -589,7 +602,7 @@ typedef struct _bt_private {
 	/** Init user configure file wait queue */
 	wait_queue_head_t init_user_conf_wait_q __ATTRIB_ALIGN__;
 	/** Firmware request start time */
-	struct timeval req_fw_time;
+        bt_timeval req_fw_time;
 	/** Hotplug device */
 	struct device *hotplug_device;
 	/** thread to service interrupts */
@@ -934,15 +947,21 @@ typedef struct _BT_HCI_CMD {
 	u8 data[6];
 } __ATTRIB_PACK__ BT_HCI_CMD;
 
+
 static inline void
-get_monotonic_time(struct timeval *tv)
+get_monotonic_time(bt_timeval *tv)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+        struct timespec64 ts;
+	ktime_get_raw_ts64(&ts);
+#else
 	struct timespec ts;
-
 	getrawmonotonic(&ts);
+#endif
+
 	if (tv) {
-		tv->tv_sec = ts.tv_sec;
-		tv->tv_usec = ts.tv_nsec / 1000;
+		tv->tv_sec = (u32)ts.tv_sec;
+		tv->tv_usec = (u32)ts.tv_nsec / 1000;
 	}
 }
 
diff --git a/bt/bt_init.c b/bt/bt_init.c
index cf9bfc4..fbeb210 100755
--- a/bt/bt_init.c
+++ b/bt/bt_init.c
@@ -730,6 +730,12 @@ bt_cal_config(bt_private *priv, char *cal_file, char *mac)
 
 	ENTER();
 	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,
+					      cal_file, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      bt_request_init_user_conf_callback);
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
 					      cal_file, priv->hotplug_device,
@@ -747,6 +753,7 @@ bt_cal_config(bt_private *priv, char *cal_file, char *mac)
 					      priv,
 					      bt_request_init_user_conf_callback);
 #endif
+#endif
 #endif
 		if (ret < 0) {
 			PRINTM(FATAL,
@@ -795,6 +802,12 @@ bt_cal_config_ext(bt_private *priv, char *cal_file)
 
 	ENTER();
 	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,
+					      cal_file, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      bt_request_init_user_conf_callback);
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
 					      cal_file, priv->hotplug_device,
@@ -812,6 +825,7 @@ bt_cal_config_ext(bt_private *priv, char *cal_file)
 					      priv,
 					      bt_request_init_user_conf_callback);
 #endif
+#endif
 #endif
 		if (ret < 0) {
 			PRINTM(FATAL,
diff --git a/bt/bt_main.c b/bt/bt_main.c
index d7942a9..1778ea1 100755
--- a/bt/bt_main.c
+++ b/bt/bt_main.c
@@ -369,7 +369,7 @@ bt_store_firmware_dump(bt_private *priv, u8 *buf, u32 len)
 	struct file *pfile_fwdump = NULL;
 	loff_t pos = 0;
 	u16 seqnum = 0;
-	struct timeval t;
+	bt_timeval t;
 	u32 sec;
 
 	ENTER();
diff --git a/bt/bt_proc.c b/bt/bt_proc.c
index 42be6b3..894070c 100755
--- a/bt/bt_proc.c
+++ b/bt/bt_proc.c
@@ -493,6 +493,22 @@ proc_open(struct inode *inode, struct file *file)
 	return BT_STATUS_SUCCESS;
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+/** Proc read ops */
+static const struct proc_ops proc_read_ops = {
+	.proc_read = proc_read,
+	.proc_open = proc_open,
+	.proc_release = proc_close
+};
+
+/** Proc Read-Write ops */
+static const struct proc_ops proc_rw_ops = {
+	.proc_read = proc_read,
+	.proc_write = proc_write,
+	.proc_open = proc_open,
+	.proc_release = proc_close
+};
+#else
 /** Proc read ops */
 static const struct file_operations proc_read_ops = {
 	.read = proc_read,
@@ -507,6 +523,7 @@ static const struct file_operations proc_rw_ops = {
 	.open = proc_open,
 	.release = proc_close
 };
+#endif
 
 static struct proc_private_data proc_files[] = {
 	{"status", S_IRUGO, 1024,
@@ -643,6 +660,15 @@ bt_histogram_proc_open(struct inode *inode, struct file *file)
 #endif
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+/** Histogram proc fops */
+static const struct proc_ops histogram_proc_fops = {
+	.proc_open = bt_histogram_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+#else
 /** Histogram proc fops */
 static const struct file_operations histogram_proc_fops = {
 	.owner = THIS_MODULE,
@@ -651,6 +677,7 @@ static const struct file_operations histogram_proc_fops = {
 	.llseek = seq_lseek,
 	.release = single_release,
 };
+#endif
 
 /**
  *  @brief This function initializes proc entry
diff --git a/bt/bt_sdiommc.c b/bt/bt_sdiommc.c
index 15be2b0..520a67e 100755
--- a/bt/bt_sdiommc.c
+++ b/bt/bt_sdiommc.c
@@ -693,7 +693,7 @@ sd_request_fw_dpc(const struct firmware *fw_firmware, void *context)
 	bt_private *priv = (bt_private *)context;
 	struct sdio_mmc_card *card = NULL;
 	struct m_dev *m_dev_bt = NULL;
-	struct timeval tstamp;
+	bt_timeval tstamp;
 	int index;
 
 	ENTER();
@@ -838,6 +838,12 @@ sd_download_firmware_w_helper(bt_private *priv)
 
 	PRINTM(MSG, "BT Request firmware: %s\n", cur_fw_name);
 	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,
+					      cur_fw_name, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      sd_request_fw_callback);
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
 					      cur_fw_name, priv->hotplug_device,
@@ -853,6 +859,7 @@ sd_download_firmware_w_helper(bt_private *priv)
 					      cur_fw_name, priv->hotplug_device,
 					      priv, sd_request_fw_callback);
 #endif
+#endif
 #endif
 		if (ret < 0)
 			PRINTM(FATAL,
diff --git a/bt/mbt_char.c b/bt/mbt_char.c
index 2f64382..69a8293 100755
--- a/bt/mbt_char.c
+++ b/bt/mbt_char.c
@@ -96,6 +96,9 @@ mbtchar_chmod(char *name, mode_t mode)
 	struct iattr newattrs;
 	int ret;
 	int retrycount = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+        struct user_namespace *mnt_userns;
+#endif
 
 	ENTER();
 	do {
@@ -120,6 +123,13 @@ mbtchar_chmod(char *name, mode_t mode)
 #endif
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+        mnt_userns = mnt_user_ns(path.mnt);
+	if (inode->i_op->setattr)
+		ret = inode->i_op->setattr(mnt_userns, path.dentry, &newattrs);
+	else
+		ret = simple_setattr(mnt_userns, path.dentry, &newattrs);
+#else
 	if (inode->i_op->setattr)
 		ret = inode->i_op->setattr(path.dentry, &newattrs);
 	else
@@ -128,6 +138,7 @@ mbtchar_chmod(char *name, mode_t mode)
 #else
 		ret = inode_setattr(inode, &newattrs);
 #endif
+#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
 	mutex_unlock(&inode->i_mutex);
@@ -161,6 +172,9 @@ mbtchar_chown(char *name, uid_t user, gid_t group)
 	struct iattr newattrs;
 	int ret = 0;
 	int retrycount = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+        struct user_namespace *mnt_userns;
+#endif
 
 	ENTER();
 	do {
@@ -202,6 +216,13 @@ mbtchar_chown(char *name, uid_t user, gid_t group)
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5,10,0)
+        mnt_userns = mnt_user_ns(path.mnt);
+	if (inode->i_op->setattr)
+		ret = inode->i_op->setattr(mnt_userns, path.dentry, &newattrs);
+	else
+		ret = simple_setattr(mnt_userns, path.dentry, &newattrs);
+#else
 	if (inode->i_op->setattr)
 		ret = inode->i_op->setattr(path.dentry, &newattrs);
 	else
@@ -210,6 +231,7 @@ mbtchar_chown(char *name, uid_t user, gid_t group)
 #else
 		ret = inode_setattr(inode, &newattrs);
 #endif
+#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
 	mutex_unlock(&inode->i_mutex);
-- 
2.30.2

